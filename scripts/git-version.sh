#!/bin/bash

# git-version.sh - Generate version strings from Git repository information
# Similar to setuptools-scm for Python
#
# Usage:
#   ./git-version.sh [OPTIONS]
#
# Options:
#   --tag-regex PATTERN  Regex pattern to match specific tags (e.g. "server-v")
#   --lang LANGUAGE      Generate language-specific output (e.g. "python")
#
# Example:
#   ./git-version.sh --tag-regex "server-"                 # Extract version from server-v* tags
#   ./git-version.sh --tag-regex "frontend-" --lang python # Generate Python version assignment
#   ./git-version.sh > version.txt                         # Redirect output to a file

set -e

# Function to check if git is available and find repository root
check_git() {
  if ! command -v git &> /dev/null; then
    echo "ERROR: Git is not installed or not in PATH" >&2
    exit 1
  fi
  
  # Try to find git repository root, looking upward if needed
  local original_dir=$(pwd)
  
  # Use git rev-parse to find .git directory or repository root
  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    # Not in a git repository at all
    echo "ERROR: Not inside a git repository" >&2
    exit 1
  fi
  
  # Change to the git root directory
  local git_root=$(git rev-parse --show-toplevel)
  if [[ -n "$git_root" ]]; then
    if [[ "$(pwd)" != "$git_root" ]]; then
      echo "Found git repository root at: $git_root" >&2
      cd "$git_root"
    fi
  else
    echo "ERROR: Could not determine git repository root" >&2
    exit 1
  fi
}

# Function to get the nearest tag
get_nearest_tag() {
  local pattern="$1"
  
  if [[ -n "$pattern" ]]; then
    # Get all tags that match the pattern, sort by version, and take the newest
    git tag -l "${pattern}*" | sort -V | tail -n 1 2>/dev/null || echo ""
  else
    # No pattern specified, just get the most recent tag
    git describe --tags --abbrev=0 2>/dev/null || echo ""
  fi
}

# Function to get local version parts
get_local_version() {
  local tag="$1"
  local distance=$(git rev-list "$tag"..HEAD --count 2>/dev/null || echo "0")
  local commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
  
  # Format: distance.gCOMMIT_HASH (note the 'g' prefix for git)
  echo "${distance}.g${commit_hash}"
}

# Function to get dirty marker
is_dirty() {
  if [[ -n "$(git status --porcelain 2>/dev/null)" ]]; then
    echo ".dirty"
  else
    echo ""
  fi
}

# Function to get current timestamp in ISO format
get_timestamp() {
  # Format: YYYY-MM-DDTHH:MM:SSZ
  date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u +"%Y%m%d%H%M%S"
}

# Language templates
get_language_template() {
  local lang="$1"
  local version="$2"
  
  case "$lang" in
    "python")
      cat << EOF
# Auto-generated by git-version.sh
__version__="${version}"
EOF
      ;;
    "json")
      cat << EOF
{
  "version": "${version}"
}
EOF
      ;;
    *)
      echo "ERROR: Unsupported language: $lang" >&2
      exit 1
      ;;
  esac
}

# Append dirty marker if needed
append_dirty_marker() {
  local version="$1"
  local dirty_marker="$2"
  
  if [[ -n "$dirty_marker" ]]; then
    echo "${version}${dirty_marker}"
  else
    echo "$version"
  fi
}

# Function to get version from latest tag
get_tag_version() {
  local tag="$1"
  local pattern="$2"
  
  if [[ -n "$pattern" ]]; then
    # Extract version from tag using the pattern
    # This handles formats like "server-v1.2.3" or "frontend-v2.0.0"
    echo "$tag" | sed -E "s/^${pattern}v?//"
  else
    # No pattern specified, just remove 'v' prefix if present
    echo "$tag" | sed 's/^v//'
  fi
}

# Function to get the branch name
get_branch_name() {
  local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  if [[ "$branch" == "HEAD" ]]; then
    # Detached HEAD state, just use the commit hash
    echo "detached"
  else
    echo "$branch"
  fi
}

# Function to get fallback version when no tags exist
get_fallback_version() {
  local commit_count=$(git rev-list --count HEAD 2>/dev/null || echo "0")
  local commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
  
  echo "0.0.0.dev${commit_count}+g${commit_hash}"
}

# Main function to generate the version string
generate_version() {
  local pattern="$1"
  check_git
  
  local tag=$(get_nearest_tag "$pattern")
  local branch=$(get_branch_name)
  local dirty_marker=$(is_dirty)
  local timestamp=$(get_timestamp)
  
  # If we have a tag, use it as base version
  if [[ -n "$tag" ]]; then
    local version=$(get_tag_version "$tag" "$pattern")
    local local_ver=$(get_local_version "$tag")
    
    # If we're exactly on a tag and not dirty
    if [[ "$local_ver" == "0.gunknown" || "$local_ver" == "0.g"* ]] && [[ -z "$dirty_marker" ]]; then
      echo "${version}.${timestamp}"
    else
      # Distance from tag, include local version part
      distance=$(echo "$local_ver" | cut -d. -f1)
      commit=$(echo "$local_ver" | cut -d. -f2)
      
      # If we're on a development/feature branch, add dev suffix
      if [[ "$branch" != "main" && "$branch" != "master" ]]; then
        version="${version}.dev${distance}+${commit}"
      else
        version="${version}.post${distance}+${commit}"
      fi
      
      # Append dirty marker if needed
      version="$(append_dirty_marker "$version" "$dirty_marker")"
      
      # Append timestamp
      echo "${version}.${timestamp}"
    fi
  else
    # No tags found, use fallback versioning
    fallback="$(get_fallback_version)"
    version="$(append_dirty_marker "$fallback" "$dirty_marker")"
    echo "${version}.${timestamp}"
  fi
}

# Parse arguments
pattern=""
language=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --tag-regex)
      pattern="$2"
      shift 2
      ;;
    --lang)
      language="$2"
      shift 2
      ;;
    --*)
      echo "ERROR: Unknown option: $1" >&2
      exit 1
      ;;
    *)
      echo "ERROR: Unexpected argument: $1" >&2
      exit 1
      ;;
  esac
done

# Store original directory to return to it later
original_dir=$(pwd)

# Output the version
version=$(generate_version "$pattern")

# Return to original directory
cd "$original_dir"

# Apply language template if specified
if [[ -n "$language" ]]; then
  get_language_template "$language" "$version"
else
  echo "$version"
fi